/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
import { Minipass } from 'minipass';
import { Ignore } from './ignore.js';
import { Processor } from './processor.js';
const makeIgnore = (ignore, opts) => typeof ignore === 'string'
    ? new Ignore([ignore], opts)
    : Array.isArray(ignore)
        ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
export class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        if (opts.ignore) {
            this.#ignore = makeIgnore(opts.ignore, opts);
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)
            ? e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep)
                ? '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
           · ª=ÆóûÙõD
® åzj¹¶0$=ºßö¹&ù6ù¡¦–˜©œ~å8‰İA¢;–×D	òêŞXJ	Jİf8›:[TUdÆÃ¼*‹¤+å–©Â\Eõğq}êª²»#uõÄ¥•c(t}¡ˆsÓUm"¤t:¡–¥Òø’MŒg¿ŒAsÚsÄYpvSå2[¡9Ã:a/dBaüKr5ú{9ËøyƒªÅ®8¾fJşÚÌ- ¼Ñ’&ëqÒÏh£†_M!6ï„ß_zİô9ìÙŠ&™%ã#pó®sA~fH,S¢×à€ /]¶À/™–óAEêüê½!wÁ_!]ëuº¯rÏÒ(ø‚>ãyRÃÑâÇÑº|ˆØöLBİQú³=‘‘ŒõNıóö°PÅN„GAiÍÇxÚYŸO7h"çuT¼ÃDz#XãÒ;í{o„ö‡Qömj²¶ Ä¬:¢âVi#«\¾Û ]H“Û·EôúQ^¦!å¦‘Ëo‚ÖÖÆ+xùj ŠƒlSMøÍÑ=Æ©ªÜ…<Ë†:
lÚşŞ7ï|cÏ­¦k=2ë›4$'ŞM’Î'„!G¦LäôjŸ…£¨¥çYøT'~úAo$äº¨$,N\ííÏ¿ÎHK|*…ÈÜ§Ü^Á8¶@Xi_ç8j»ûÀ«¾‰FgwÏ]âNoÄ|éÉ<çCÖÕŸXñJÕ[{
k£¯'ÀpMÚ	¤æ«{¹½ujª8Åğ:Ê+ç³áS%>r#~òxEvá}éÑäøÂoíÎf”(øK#RKğƒœh¬ŞˆA¥4@ĞH8ƒğ¤Åƒ7İ(ûÓ+›@ ì¨K~²C<bQmœÆ”İl[ì‘>jê%jÚmdSÍ,ÔGJíb$ÅÎÚeQ<ßÓT*ÓFöæVÏÄ±Å·mÍåëÌ'º½ÃH-Ø°ùÒÑ}Jv8^ƒ¡t£!¶m|é$½M^)p^"WÔ´–ıÔZ³Jd|J¦Ä]¾I&9–š=$O7…ĞŸhÈI=Mê”y¿èëz;­ÈÛ›Z£ØûÍŸ&E´„Ï[c?¨Ë'ó[’xÆ”»QL’Môo&Ñ"®“|šìàóeW6nf®ĞÕNA¹ÌpÂ³œVôBšŠàŒ·ı ¹ƒ|\ŒTJç®}
æYÓĞ\ØB`(‡hÌZMw CÜ½ŸÜ½ËğY‘–ıSº``xŠ‚¥V£Ázït£†tñÁ:†2¬rùğ6p÷¯ºàhúrÌñG<Š.±ëÊÈ=›•İ—•ãä’´EøÇ÷¼ÒwMK¿ûdNîøá¹˜â¤øhx¡ŸRT5C†P:€E.¡úB¾!Fã"7ãÏÃ"RŒâ0õÕ"W2û8Ç³[m±=ØéüÊ ±ğF5¥â>	ªW¯Q?ı(|a›÷#íj+†Ö}fÖ ©ã3Ø·Uí‰^©¡\ºo·bÜ»^2Fğ@ªÜ	Ó˜cÖÉÛ™å×±y]ÉÈnªdàî][|v’³¡‰«¾©s‡iÈ´ñÁå¥š—“Ä'¹à~^·cM¸GÍ&2vİ´‚Äçxf³üõÌm`†*ç:’¸ÃşÊ¾3j}˜tUŸ@=ws
àıú3:ßÍ¡»dfî Ø}Ñut¦Ò—%Tpö¸V’ú™ÌÃ™f	oR!¿¤¾0ƒjÒ)<UÙ Èğ¹õå=+Õä¼ò€¢~o‰z¶¼3½Gz¶ t„œ/ä»äNNÎ¾¯/…Z‹1èÑ ±IÍ¾‹Õ£çôÏã¡«†¹9®Ôµy&M²ĞÉÌ@ÈSàyë?v®ˆ·˜¯îàã‹Èéï€æfGS–İ÷°ÚÙFTW°-D,ÎÈX½~¾x÷c$ ë 8Ï%Àî¡‚P­Ô	Ëà“}”p­Ê÷CHµçDx®ŒÖ¿LÏˆß§¤xm>Î’¯ÚÚ²f™ú"HiTx{€`6çš"Ûq!Î•€Ùm¬p{ ÿ6n«ø×á#G\&½GjØ[Ñş—)ı_*C,»+a²¼å!”yçÙ!_So¾±®[ş½xÁ¸˜_@t÷¾màêfùê^-Û(V÷‡{c]¢ìGÒ‰f5±p·îREÚ±_NÿÛLäĞ­µl©ÈQÈ®FÄ¬½&¢ê`ÔS±Â›Á?ÿ¬®{O-š#Pğÿ£ºîC¼F‡’—ç™Ã¼7g×1y^’"ØÃáÄúVÑÂ“ê[5Br&ÉØş£{]^ó{aøÃØ²³£_ •“Å\¨É*O‡ÈŒ”ÅM÷aÊ‘»8­‚‘g	¯üš!D ³FÍı‰š3„`»€Ÿ’FÎ¦òìÕˆayš|&‡Tcá"¢ÒnB±ùöGïÂÖí°Üv©=ÖãTbsÿ©#ìg][!V›$ öàºk"œ½¸±ø?Òšr?Wóz^Ã®NŸCËkÔWäF}Átá—ÌËÄ‘‹CX’@Ê:'2brãæ<İI±ECƒq7åÔş¬¸5n“u}‰Y?OmüG!êy1yªe¬¤÷6]^Yp‰¹aè[÷¬Dõøu|S´b—p4©Øú‘Ê£ÆAÑÖ4¡œF Æ¯Ôé&{8RjÇÙR¶häeİfõb'u×F»º÷>${Öb}Ï&&s·ÍÓ–ğ„•Ì¯‰ l#5`Œ«?„ÛeoKÌ´‰™+àƒYäiÁË­\Å¹ÁwVµf¦ø}&xãD+ ;–}š!ŸŞªªÔŸæêZ"C6>-|±£šPC3Bã©—•üccÚà“2
°İˆú+µÚ"Æ“X30ë’ÉÁìk
6qøİ‰ƒÎÊ+ÆN;IeMü	` —"Y—ÌlîO'3@Šzfù­Äà¿’Öœq3…Wåı³uzQ «kÙRÅ,ÄÊ»—»>‰{P.è0û<»H±§2¹¿M÷§)·i5ß¯nk:#Š7¶s>‡!Ÿbkş^L[C­Ót§}”óÂy ãàEùGÃ,o*o‡ÎöĞxâÕn»YÉ{¤âél©ïgá0±1³˜ûœi¬×aïMïÃ4 Œ¹*'C§ºëd•:–Ëbï¨z×Äa|DÚ•‘ŞùˆÔòÎ:– v,®ìœ OJà,Ú¡®™AC}QØòÁN¥9Cô: Öó×€$Üª–òŒ¼[Í§YNÙvFg›G	ÛKöH•!	üÉ#¼Áö Œh2Ï^ÔĞí£R€/#CP&ewFl9{OŒ¨àgxPØ´âòVhÊ%Jk¯İiÓ¬ÆßÒŞ›ÁQÂoO‘®{ÈÈß5¸®ºúÌÀ.6{æ@Ï´>×Ï¡LX	k^®ElÔt¥„ˆ}¿ıvïHC¦~ï\Â‰Ç¸P-CVŞ…µ'8®ÅezÑEk|„+WĞ{dc<ÑDbw™|b‚°6o(¹´1Äâ¡ÁËÁuŞCf›GÜ YË8ÿ2¿Ìò¸ÎÜÆ@ÕBxï…PXw‡sÃİ–™ÛGªÍ…—v<³Rk('jïœGPI%¢´ŸÑM±é2Iålß°ı™â¹àHîN3®y/s?l„1V8?ĞÈq0Y¹¹½¦C5Ğ½õJIu!£‹Ç5Š©8‹£‘¶·Ğş)ø­[÷¶ä"{øñu*Ê¹TkóÒ(4.BzdÑ_µ7Ü:8ñõ ùRƒˆë_p•ÚW›xê¦ºoÂ0ì%8¯löq]¤‹ŒÙæ‚Ç„\†ëÓ8ß©lB’ë)?Æü®±ß€x%"•|Ãƒ*u«h¼¥ïªŞR~¯†Óî~ŞÕ05‹c°áÎ»rŠ’^K'­²Ú÷AƒxXˆ¯$§İšÇÈ&{}É. ÔmHàm|3’’Ç­€¦İnr.çô¢Je„ã¹6wüU­gõI‡BKÏàfVI!63CâÂµ¶ÒÉô»:¶0\V)ôV‡Wu-±ì_:b9ş¼ÒÒ†øtè@3•ıšÏÈ³
3«¯C¢‘°„Pl=Õ•ö†Ê:vhÈÆ´YÁ=Yå¼8Ó¼ªèı|¾şå°»p?'^n¤«ì}N³ü ÒSÒ5G#›¿r\6-,æ!_tÑY¨unó
r¹­áx‹JÁOmÍ9Oí&óó¨Ög•\$t^(Õ1±`°RC~ß?Ï@ßfnÁÍğ%Üß¢¼ôãIµõ1Se'¨ŞªA²êkZ5:;ë©èW™şóïÆQäv+É'¼I!{F×Ø}òá º‘ûÆ>È1×4'ï½i4ª¡™¸ƒóÌp3—“»¿»w³¯vÛ’¥=\µ›¿ x·`õ¦³Œ	Õp—İÖpÖ*‡_[˜«i|®qèÏBz–GVeÜr"$¾ÜâÏÁşeõ!³nbLü<-òº3wŸœTF+gTPG†+ş¸7ÊÑŒÍòÅÌ±¨‹°¬ÏãÃAßÂil™‡‘SF„.ª°Fãšã.ƒ‹#¸#ÆbÃ¤•5zÒ¾¹Ü
î=p¿é…¯ËÊæA^Æ˜BŞLDXfnD#ÏÇÆôêb¿Cè¬¾º¾+§)êõİ
”Âã©l„˜aõv&`º]Zßuºc.¡¨¨ùf­ŠKäbªÔó/€Ñ‰Ä•µ
şn¿â<FUÜ<âÜˆôµ®-†‘º£“ëvİ×s}¨<]ˆDP&tkØr˜×—½÷Š× ±2t¶ÒúÕÑ1®KXÎõyWGDwc&o/Üºæˆ®ÎàïEz“™=X}iHÚ{Æ¦ÆZ÷Â¹=´`Ú¹å"ˆm!rqDæ½‡(ñL*¶€x ÃjÕ¢YZGõ1ç…ö×ŒŠ5ÄhŒ4
Õ0‚î ºbz©õİ£éÏí6$u\jÀ©‹ò¶„ğ›®wKoóQëÔm¯Z×êSd,Äœ3