{"version":3,"file":"gen-mapping.mjs","sources":["../src/sourcemap-segment.ts","../src/gen-mapping.ts"],"sourcesContent":["type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n","import { SetArray, put, remove } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private declare _names: SetArray<string>;\n  private declare _sources: SetArray<string>;\n  private declare _sourcesContent: (string | null)[];\n  private declare _mappings: SourceMapSegment[][];\n  private declare _ignoreList: SetArray<number>;\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n}\n\ninterface PublicMap {\n  _names: GenMapping['_names'];\n  _sources: GenMapping['_sources'];\n  _sourcesContent: GenMapping['_sourcesContent'];\n  _mappings: GenMapping['_mappings'];\n  _ignoreList: GenMapping['_ignoreList'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: null,\n  sourceLine?: null,\n  sourceColumn?: null,\n  name?: null,\n  content?: null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name?: null,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name: string,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: string | null,\n  sourceLine?: number | null,\n  sourceColumn?: number | null,\n  name?: string | null,\n  content?: string | null,\n): void {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n}\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: null;\n    original?: null;\n    name?: null;\n    content?: null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name?: null;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name: string;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: string | null;\n    original?: Pos | null;\n    name?: string | null;\n    content?: string | null;\n  },\n): void {\n  return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n}\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport const maybeAddSegment: typeof addSegment = (\n  map,\n  genLine,\n  genColumn,\n  source,\n  sourceLine,\n  sourceColumn,\n  name,\n  content,\n) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n};\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport const maybeAddMapping: typeof addMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport function setSourceContent(map: GenMapping, source: string, content: string | null): void {\n  const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\n\nexport function setIgnore(map: GenMapping, source: string, ignore = true) {\n  const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toDecodedMap(map: GenMapping): DecodedSourceMap {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList,\n  } = cast(map);\n  removeEmptyFinalLines(mappings);\n\n  return {\n    version: 3,\n    file: map.file || undefined,\n    names: names.array,\n    sourceRoot: map.sourceRoot || undefined,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    ignoreList: ignoreList.array,\n  };\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toEncodedMap(map: GenMapping): EncodedSourceMap {\n  const decoded = toDecodedMap(map);\n  return {\n    ...decoded,\n    mappings: encode(decoded.mappings as SourceMapSegment[][]),\n  };\n}\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport function fromMap(input: SourceMapInput): GenMapping {\n  const map = new TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n  putAll(cast(gen)._names, map.names);\n  putAll(cast(gen)._sources, map.sources as string[]);\n  cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast(gen)._mappings = decodedMappings(map) as GenMapping['_mappings'];\n  if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n\n  return gen;\n}\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport function allMappings(map: GenMapping): Mapping[] {\n  const out: Mapping[] = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source: string | undefined = undefined;\n      let original: Pos | undefined = undefined;\n      let name: string | undefined = undefined;\n\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n\n      out.push({ generated, source, original, name } as Mapping);\n    }\n  }\n\n  return out;\n}\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n): void {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n  } = cast(map);\n  const line = getLine(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n\n  // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n  // isn't nullish.\n  assert<number>(sourceLine);\n  assert<number>(sourceColumn);\n\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n\n  return insert(\n    line,\n    index,\n    name\n      ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n      : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n  );\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll<T extends string | number>(setarr: SetArray<T>, array: T[]) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source as string,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n"],"names":[],"mappings":"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¡rÈ5Ó¿=Ç]§ú«¾ŸvtŞZ÷Rë9[¼&ußCp>Ş%7„ÄOOg/øÿ®3ÅhßB×`]égıy¢ôk|mäsjvn²/ÎÈÕëÀ‡˜ãS(>Ú<%0‡JÊ½84Tx‚¿~ö2å±¥V&<wUON’¨iN‹†ıFÔ´\¯¯Üı>´/Ü[bSH³‚CoâVrk–°ƒo‘ø–”W2=Ó|eš±âiHñQc¤ŠóQ“ó–¤QîMÑĞï—‡¸üt-!ÅB¤†‡dp3+9ÔRY´&¨ÿLòÊ69|IÙiTí¼Õ¢¾Q«|è@Rã(€O!;rjTomüºÓù+eÂ˜†Âó<ÆìéfQ’İš˜oÍŞµ¤y›Ju¢aEHK™¦ÄKQg$8~ÅrÙÅ[ã§Ğ7î[fL¯l<ty•ú”²K+·{ŞæwvgÊD·¸Te6e3F‚Îyk$øÏÙı÷cD¨.Îhsy”8°9ÁÅQº^³L­Ã=«3O—´Ùwéšà¤Æñ/–iÆ$ïvŸRéıéN*YyĞ†¢AcÅµğè.µ2Rwºi×usĞö]›2i¦ìI¾yÚÙ‹ƒ-9İÉ½÷›MAÍ22ÇVâÕÉÇVh-m@Œ[{«~hÀ7-VY Ê´³%éÅ…(!]œ%±Vä&¸ğÕ/)–»†'²¶ü(/B`hZDË£øi×ü½kCÉœÆ¿²±Å*÷USºvëTÙíîÅaİ6ĞMDÓ&“O6'7"¼³Š“mdúIÏŸó*¸}¬¤êJ#yÃä¤ü+VïÉ”ÜtÎ@)q@÷<.1­eöS}ø)eÑËŒ>€bŒ–â3ı«•nIÏV$œ8gtñİòV³!#k°ì¦D÷Â¯¢”ÌÀO1”î	,·o˜[ÉIÒ¯ëzyj¯'õ^ª’áÄTÿRÏí99§;ÇÒœfk7½8n8Y &ÔdSdŸÒÑÔ¸r¦ÅŒW{T`˜K(Œ¹ésš’íc¼ôS÷C
KÉíeüu-dí?à)‡¿æVù(wŠZç´W!º Å£8ªkî%‡à@Ñ§çlNÑÎi=.u:eByš©±’Ó$¤û1Nâ«¼ç¼	õYó¦º“ï9·kŒ•»P6: d–<KŠÊ])5)1Ê§YÓ'›uon$NÎ#}ºdKÕ>İ#¼+İ{Ü[K[ÅP>ÅIwåF!Ü)¥I–Ê‘®KY`Ì1FæSN(å™™IÉSú%º8`6/”_|ÕûœˆJƒVê(ÊUF™†Í~ğ9¿ŠY]ËŒV¹ÊÃ”•ÃdÜCÉ…]§|IÎ0ÂÜ«hEF…Õ9„o]¿%“ä<F!:5faVleG•B‹Ì¨T²§ü›uœOÅ	n„Pƒ®¿9M‹SêoF¹¸Õ0s•–ô.Î)©Ø_¬U×PAPu¯j&æm]kqÃ-·.)mú"gM¹¬êbÔ¼îÁ¹iâí_~5©¦HRœ!võ&d	çŒÙz)ÏŒêÒìm™ÿœõƒ¹MJÉ"›û’ì½ÕN1'R]ÒšHÜœ
T«$h¨¥’­^(ª²ÁPª—mÙÈÊ·*cè¥1kÉ¬~SÁŸØ<ª‚ëM}qÈ%Fü$’$’%©ÁIÌôJ°TèK™LKN¨¦-šC¯|İŞ^"²œ*Tûz™t‹Ù´q‹u*›Œ"[À,¼{AÊ§¦.Kd¼H°
%9Ò™LÉt¡3ƒ´£Iö;G³íZ6M©äRDËM%RÚ-Y"(ÃHõè:KÈ`*%÷ŒšQñ­º#4ÛŞŞ>#åô<Zvİ²”şúÏk*C<õ²n§VŒ¨Á„µ»/³ßÍ[guwærE¨);‡R²^Kgb© pÅ8Y«‘Šiié¹¬ÁìZôúĞÖĞrZÊRÉºç±®´Ï´…è¥•’VÚÖæ†Ñà•ºNÃ¬Õ‰ëËmnœ®™ì¡ÌWºFK•İPªno†vöŒËíÁ#İÉŠ¿Õe(*µõZ˜™j‰P/%§;³o%c€ÂË²ÊD7H(¶;)—J¦©¸Ã¤'‹CP©ş<ŠÊFw çól‚J•W¥Ó@êq½ši—íuslÏIÊ5ÕVR`0ˆ¶jôŒ¨i£»ÜÏy,âª¹èµ©. İKhC?Fš¾;İvÍQdÑ$BÏ«ÉjÒùÈŒ4Q®›mRj÷´Õr(¨ û—‰&
Õş‘}„Ñ+6Å‘İ®•Êt{{·fL'ØtÚuaÚ[ûôDg@ÁÂY³6•xëÁ5g(]|÷pYİİ´¡ÛL…–ˆ2Ìİ™WzHHêÄv›kÒµš…Hc¢Mílƒ¤bÏ…e,:ÕBÉ3Œ·¯÷¢ iIy¶zÓ…w+A’NJº\g›$Iˆg¤…gFR ÉZM6­ş¦èf€^i>Ê§Å.Ä2§˜Aç[,øgØ”İg™ƒÂ–÷qP&ŸIT@7_¼'ùğ%hFTÏy€â4‹òl;xşÒ+±Î’¢ºâr’Ê“²¹„—²!ÄmÉßÅïIÙ †Ÿ³ßÆg”}kğA%™
ÙSËŸü…gí‡`¡¿?6¿’’vXÉ&yÃıæü,&‘2¶#dá²B`Æ´­€ª1“T*™qÍ£c#¼[—ÈŸû˜?ôˆpˆE†S•İÖUœˆ€ıväåSs‚ªÅÂWk¯ĞÙJÕçá‚õ=›R	ƒ`ÄûbíLQKQeËy…—#U{Ltœ\c#"W
Kµ-$9‡ªO‹XFV„ù§Öª=|Á}ñV>@^M•±ørF•%¨vq‚R9”o	\1$O"¦¼+¬º"• ¡ˆÅŒ=T£òÎLTÄÀFV•5N‰;¢µ‡¶İ€PØ¢sÖ—`@±=>	1áÂ[‘ù(Àš/Õ5–Ûo[6libTrwêH§)LµQ=ÙpcÄ…´0/6O%Ë*áº¥ˆVT^Êë6ãdÑÈ i4UÖ,x¿l ¤Ùâ<©ìW]’ Ï eèKPÑ|Ñb(ÕeãºL—:®^‰r‰­nÚº½ú„°™ºcˆ%Ô‹`}Ô2¹'ğR`ßHª"Qb£@¤ŞğûÅQm°‹º2A57_Ä•	,S‰ÚŒª8ƒ¹Je¯6Ğ@½câ#ü„Su©}¤,ñS’ßKhµ¢‘(M•ëÊÖpº¡¡ó˜ú@¾øm‘ü:¡w§å‡R”ªTŠ 9´WÄ R¬ÚT+±Hõí$;è|¹½’Ñ-­KšS‹0 -ÒåºqİË©‚[ä^­ÆiÒ¯,ĞæZ„\»;è&|™g6¤êàµZh1¦>İ'yvfhâRm,°Q¸h
 ³zfŠÙã¦àsª”{œ ± Ÿ©rÉàc~g”›¿yEˆP¬ò´6ÁèQcE”»r-)ËTz¬Ó¼ìI×³áæ«°YÛ·±¨’úhcœ†ÂFE=Òmâ·ğ5Z´-4±Pô Sû±ÁJqd’Œ;,±½ˆ)ÇêXf	òç-3Øº:¨jœà^'¨X4üê n¹1–Ÿxÿú†šR)éÊ™HÊÛ<$j(Û)–•’7
µ7,ÎÖDMy
]·´¶O¹Êáÿ‹b¢X=î¡Åt›÷UÔ‡AKÒ	3IÓ2‚³2:•!­ç©À½<SÅ±¤[1CšŞÂˆ“(sÛ&€]L\eÍüâc}H¿–P6`hëÅD¹rzæ3¥Ï0¿s¥‹e:ÁÊÎ›ñ´Ö"«³¹2Ğ³s51¸$ ¿ÍDHö?W¤0åÜk­
Ç.×	¼ã¨şd- ”åÆœËê½bº¨ÖWÛØë•2•Q`nçIõ&T¨íş¤Ø‰¶% v‘¤¾¶4ªùª:Ş™C²*îVÆÈqO|^	oeÆkÊ(ğÉJëiÔLeFÑës¹ËÕhäÁæK«¼a@iñëª®6	¨Íz0ËŸZ¥Åä%Mò	·¶‹ËWŒ„ƒ&5Gä™§pC“?Jé¸ÂoŸg´Àz³„xAkvütÄK`Gœ;^Ü|ØéÙÓˆ”%Ìx È!ÉLiØIÂ|$ƒKØca§‡¼?r Slù0\ÕÎ#«¶Z™y¦]V¬¸Qè¦	4€âÊ‹(DÂû¦}£ë‡æ+ƒªb:Õ`ß`¬øƒâàd¶IáìÀ·ÁØ®ğäX°[.ô©Vùy Ù(Oè!i0y€£,[R£‰èÍu¨±q[	¨+€Ã	|Xº¹õqúˆxHNt8VœaŞNt•–+@¿I—O›d|”":ƒ#¬I­f¨€å#PU¼Ä­“­Oª…øxm9Ëgn=¿˜óÙJ8¯Úb³O_¯mÚ¦½¤}IKß$÷)ßeï>['gg®KvJsİ—4·}ùn9o
HÆs“³Œ€}²Ù&ç!û’öİ,¿`A=À¨îIÀ›i B$ÿ(n$²ı^z¥š[[Ió·TSEiÛŞü”ö›d¿~bÅ)÷-¶!Ïr_ğl±û¾VÌVG‚{D,/}2,uË”ÏD!iû˜«ç}=¥®cš:EH (³ƒË@EXÂŠØ²R¯Âéâó…C{‹ÆCu¨Ãú@·Lõü@LeIÌ_’åÆ9lÅ~Î÷ØJøQç´åêóXÛå»m$Q, ‡%)WhlÚÏéDé½ù{PåCFøhÜHæløIqIÓŠ¸ÊuÃ:SB'\Õ Ú…ˆ úó>œ’³T	FZxpümDPü°Ğt–níTñá£ls§Şé”iğ±“ì‡Z"… Ñ P2
`ƒNÊÚC¤Ğ÷é.håñ8áN{9tĞ¼•ÂaV¹8ècààm»¤f3£í¦ã7vº¦:ˆ¦ª;u?{ü±w§³´	S&Î¬¬ûô<‚óxômÒ§i“%­°1Lí9¦ P5Ï¡:qÔwæ¸È7§õrİí–ÎÌkû7€³_œüš‚äw(W‡ "Yù3¶é3^ĞÉ3?áAû¹;¥3Hs”àRê–ê™a•¢^-Ì3]¹Ğªêq ‘Öq‘_T>±4±XÙ†HAf†vævØS’Ñ9öI¼Ğsd6j=ah{ÓšÑéÓúfZr¡5`V.tjzyĞ±Ö‡p9ÓhXoqü¸|Ÿğ7yN.£
†çv4fPÈ1CÌ*‚å*G2ş$1X|œ™'1Uá 6Q’"Aµ±dŒrp&Jïˆæã9$JªŒµ>Fk:ë‡	tÚiÖh¥X-GåEßÃšg­
Z›§dÇ™E· 5´\âo£fG_»Æw*Ëšn…í›Óy6eúiÎ$Åµt«ça`ÍkB\´‹ü|:?‡t»4Û›%í°ÍuO;â›OûO79`¢LÖÉâ1™[çñ˜<wçt†iôSˆjÖòiıñsÿÀÌèD´,á6œ9&—'aUBä™DŸB6ßtjc°$wH“‘â.Vü“‘1EÍj‚Å8d*qÌ|HL‡³Æ2~­êÕtÛ4e’¢G«QR¤bş±ûã)W0¼™ú­ SAm%öQjM€–Õ„cÆ£¨¾wibÏ >a°rXÚ‡ÙÍ›‘ÀçJ'¿K¾1‘VBFZFú1v£šÂº}Í,Ï‚ÉÓÉÓM§“F›h¨šbpó9Ü|6@bÉZü“2Ò‰lâ¡@øĞ–õp¼šÔ6F6Œ§N0~jcó¥¢SqúNß)È1İ!­£î® Ìüóx„¼Á:„O4Áò¯†\§?šâMH«Ñ¸¬ja#õOûOÿä¹_†Â¦ßúDÄıÙç±¹šf?ıÖæè4†yà­ˆ¤‚,v"N!›Oÿ3Ña$-ƒíx˜Ç^äÕİ¤ç*Ê#7}S íy7|¬ÔC}Åªèš^û'±
m‡¨¦I;…]Ü°|îr´0}K+wtG1c‘CêVØP3|¡ÿ$B—¬Ô&‘/bk
Î|“ÜY†gFR¤Øâ2Äiì90)Åy´Ó;ñÏ"?ÿüaù†S)`×‰ÅËögSımPŞ{Ò÷Ş"÷Åİ¡å‚ä)–“V‡sÉ†¸CmèÿÕ6õƒóÀiÖ’ÇğGH…–
ÃQ#·´º©YzÙ„ï¨
¤hltèLÛºL=`ÏÓ
Ì0iKİ\=”ÕŒı)_AVºûeÕÓ¦©­L8Z°ÂãmDİZáp­FÎ›‘‘Ô¹Hµıt¾ÍCù(‚‡Õ/†_L§UfÍ°Ú3øôŸäöúÌÙÅª-ÆğU/F3]©g¦Æìl>í·zÊã¶¥klÅ|ºÏ 4,/ãåŸkÕg´`ŸÇÃí•1ˆ¤)ÅÇİ?xŞ@YlÒ§—ŸØÏpøl‡›³û4>9»™]‡ÏnecH„êÑ¯~(?MVãôîÒz›fü†‘ªĞÆ	ê£‹s±l@6–´µ³2j‡Ú[veÕO§õÖò40‹N{íüé[=“ÉiÿiÓ: _~ô×Vy£7·|Ã—^:Öê,“vºQÃß¡¾É_Y¦^1ètr©vHQHK™~ë?yw†·5Êfí8d³ —ÇÃáµR‡ŠmYvÏä3NŸİF„éÂ˜fÒE¹RùÚ}À×¤XWÈú/ì+ÌnãÙ'†ö?¡5úN/Í>¥9ŸÎÚÓşÓoaOŒwøößî¡,Õ
ÑÏ$ùQÍcØUs UÁ:lÔÔ6/c‰šNİ_g­ñféÁ(dFéNi$8¦ÖæÌ©üYyÀ;d5Ğ!bdÇ«DÙş`%ä9ç9 Â¬|Ê9×ôüz„Š¬ØréC <·‡)}¤‡#ƒl£+t?‰¬Ùä}§WŸĞjÀOdê`ğÇaÁ¬CÃô3î·’™d*\ÈG<ÿ0­oo":ã%¢ò]QûhæéŠ­¥™UhÄ¾É§óm>mÒã›vÌÔ>6)€jì)î™ ìÒmVjë#ú­óÛå‘•4‚÷!ùeC@o7ù´û'Ş·ş'
i¢Q3Ûo+qº´›ÌHÑÚws»(ôÁÖ¶ñ2rFUµª×–Úf¸„|“WÍ~O.äaÎlñ‡ÙšYÓçÁäõ$«QI‘ˆ/[.ÂÛr=ŸõŸ¡¯‡ï¤ƒÎàI4rZlbÒe9d‡t½DŒÂ#?As$|¨ïXĞúåÌ¿Ëgœ¡æQ_â±SÂõP=Ç¬äÎH«Àóï¤—“jæGgú ¾|ÉğlIš7ãha&ªy¹£0YHA=‡N¬ª4$FxÇ¢& ˜ÂgÃhêk‹„ú#ŒMÑô,>£p‰}˜lYŸâ›ÏÖ¦4€FõÔ4ƒ''™,Nê>ÈEğ¡7æ:AjŠŒ­§MtíÓd1ä5]i;l;øİs*0M\µSxäcd£MKÕ—KCç¡^k“Ë«ÃHäOÌ<-c`õ	ÖJj Ï;SB£^H.¿çä„ es¶a3nMÒ1²Uò1¦#„ëUœÇxL“Æ<l˜"eË¨µo‹•å˜ËÔöVrZ$Ö&Œ„$TpzmòIë$“ŞÊìK{Ø§=réÇg*ì¡‹nLÜsMÌ/*ß°G¿~;Ø” ¬åO¦vŸåF.ÎXûÌ§ ”Ïq:AØàŠ¥ö€Æ7ÕRš„1ÚÖv€LÑè”ºª†ÌßLN¯ÚÄ¯Và=9I™ÆØxÚ2µAÉŞµa½´~(“”?İoûmŞê"÷	06jÿ¦ƒÏÿ@äsl×‹iœ´ÕI ¤& “ƒTK]©EÕ¢†rè¬,µqÏÊ%U«ÈLP™
·Aµm	fâõu@iTí‚·6úÂ¹awz’»7siÕ@‘4U¾lãt·â#Ìİ—íuñR†8t´;ë†whÃØ6rØá0â‘´Ş¨Yˆü°9…i>—©$ƒ5Kr[#ÂÑrUAIÊ&çÖÇ ˜ú!¿0ˆÛªÍxFãÆ»z¢(ä#k‚7b2Å^™µyÒÄ«jiU³ÅËÎ~è¨Ào]ÄˆãÖ%ˆYºà®‰0=—Ìnì>›ï*µİæˆØsß29…@†µhª‰[VÆ.º^“Èå